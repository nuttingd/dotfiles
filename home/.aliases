#!/usr/bin/env bash

# aliases
# This file must be compatible w/ all shells! (Unless you want to start using
# multiple alias files again...)

# productivity
alias edf="env bash -c 'cd ~/.dotfiles; vim'"
alias notes="env bash -c 'cd ~/Notes; vim'"

# ls
alias ll="ls -l"
alias la="ls -la"
alias llR="ls -lR"
alias laR="ls -laR"
alias lt="tree -L 1"
alias lta="tree -a -L 1"

# git
gg() {
  git commit -m "$*"
}
alias ga="git add"
alias gaa="git add -A"
alias gc="git commit"
alias gfa="git fetch --all"
alias gla="git log --all --oneline --abbrev-commit --decorate --graph"
alias gl="git log --oneline --abbrev-commit --decorate --graph"
alias gs="git status"
alias gss="git status --short"
alias gd="git diff"
alias gdcs="git diff --compact-summary"
alias gds="git diff --staged"
alias gdscs="git diff --staged --compact-summary"
alias gp="git pull"
alias gpr="git pull --rebase"
alias gpff="git pull --ff-only"
alias grom="git rebase origin/main"

# docker
alias dcu="docker compose up"
alias dcud="docker compose up -d"
alias dcd="docker compose down"
alias dcdv="docker compose down -v"

# timestamps
alias cpd="date +%Y-%m-%d | pbcopy"
alias cpts="date +%Y-%m-%dT%H:%M:%S%z | pbcopy"
alias cptsutc="date -u +%Y-%m-%dT%H:%M:%SZ | pbcopy"
alias cpuuid="uuidgen | tr \"[:upper:]\" \"[:lower:]\" | pbcopy"

# ============================================
# Git worktree helper functions + gh PR helper
# Worktrees live under: ~/.worktrees/<main-repo>/<slug>
# ============================================

# -----------------------------
# Internal helpers
# -----------------------------

# Ensure we are inside a git repo
_gw_ensure_repo() {
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
    echo "Not inside a git repository" >&2
    return 1
  }
}

# Base directory where worktrees are stored
_gw_base_dir() {
  printf '%s\n' "${GIT_WORKTREE_ROOT:-$HOME/.worktrees}"
}

# Get the *main* worktree path (not the linked one)
_gw_main_repo_path() {
  _gw_ensure_repo || return 1

  local wt=""
  while read -r key value _; do
    case "$key" in
    worktree)
      wt="$value"
      break
      ;;
    esac
  done < <(git worktree list --porcelain 2>/dev/null)

  if [ -z "$wt" ]; then
    wt="$(git rev-parse --show-toplevel 2>/dev/null)" || {
      echo "Could not determine main worktree path" >&2
      return 1
    }
  fi

  printf '%s\n' "$wt"
}

# ~/.worktrees/<main-repo>
_gw_repo_dir() {
  local base main repo
  base=$(_gw_base_dir)
  main=$(_gw_main_repo_path) || return 1
  repo="$(basename "$main")"
  printf '%s\n' "${base}/${repo}"
}

# Resolve worktree path by branch name
_gw_path_for_branch() {
  local search="$1"
  local current_wt=""
  local current_branch=""

  while read -r key value _; do
    case "$key" in
    worktree)
      current_wt="$value"
      current_branch=""
      ;;
    branch)
      current_branch="${value#refs/heads/}"
      if [ "$current_branch" = "$search" ]; then
        printf '%s\n' "$current_wt"
        return 0
      fi
      ;;
    esac
  done < <(git worktree list --porcelain 2>/dev/null)

  return 1
}

# Resolve by:
# 1) full path
# 2) slug under ~/.worktrees/<repo>/
# 3) branch name
_gw_resolve_target() {
  local target="$1"

  # 1) Explicit directory path
  if [ -d "$target" ]; then
    printf '%s\n' "$(cd "$target" && pwd)"
    return 0
  fi

  # 2) Slug under ~/.worktrees/<repo>/<slug>
  local repo_dir candidate
  repo_dir=$(_gw_repo_dir 2>/dev/null) || return 1
  candidate="${repo_dir}/${target}"
  if [ -d "$candidate" ]; then
    printf '%s\n' "$candidate"
    return 0
  fi

  # 3) Branch name lookup
  local wt
  wt=$(_gw_path_for_branch "$target")
  if [ -n "$wt" ]; then
    printf '%s\n' "$wt"
    return 0
  fi

  echo "No worktree found for '$target'" >&2
  return 1
}

# -----------------------------
# Public commands
# -----------------------------

# Pretty worktree list
gwls() {
  local here repo_root
  here="$(pwd)"
  repo_root=$(_gw_main_repo_path) || return 1

  echo "Worktrees for repo: $(basename "$repo_root")"
  echo

  git worktree list --porcelain | awk -v here="$here" '
    $1 == "worktree" {
      if (wt != "") {
        cur = (wt == here ? "*" : " ")
        label = (branch == "" ? "(detached)" : branch)
        printf "%s %s  %s\n", cur, label, wt
      }
      wt = $2
      branch = ""
    }
    $1 == "branch" {
      branch = $2
      gsub("refs/heads/", "", branch)
    }
    END {
      if (wt != "") {
        cur = (wt == here ? "*" : " ")
        label = (branch == "" ? "(detached)" : branch)
        printf "%s %s  %s\n", cur, label, wt
      }
    }
  '
}

# Change directory to a worktree (slug, branch, or path)
gwcd() {
  if [ $# -ne 1 ]; then
    echo "Usage: gwcd <branch-or-slug-or-path>" >&2
    return 1
  fi

  local path
  path=$(_gw_resolve_target "$1") || return 1
  cd "$path" || return 1
}

# Create a new worktree
gwn() {
  if [ $# -lt 1 ]; then
    echo "Usage: gwn <branch> [start-point]" >&2
    return 1
  fi

  local branch="$1"
  local start="$2"
  local repo_dir target_dir

  _gw_ensure_repo || return 1
  repo_dir=$(_gw_repo_dir) || return 1
  mkdir -p "$repo_dir"

  target_dir="${repo_dir}/${branch}"

  echo "Creating worktree:"
  echo "  branch: $branch"
  [ -n "$start" ] && echo "    from: $start" || echo "    from: HEAD"
  echo "  path:   $target_dir"
  echo

  if [ -n "$start" ]; then
    git worktree add -b "$branch" "$target_dir" "$start"
  else
    git worktree add -b "$branch" "$target_dir"
  fi
}

# Remove a worktree
gwrm() {
  if [ $# -ne 1 ]; then
    echo "Usage: gwrm <branch-or-slug-or-path>" >&2
    return 1
  fi

  local path
  path=$(_gw_resolve_target "$1") || return 1
  echo "Removing worktree at: $path"
  git worktree remove "$path"
}

# Prune stale worktrees
gwprune() {
  echo "Pruning stale worktrees..."
  git worktree prune
}

# Create a GitHub PR worktree
gwpr() {
  if ! command -v gh >/dev/null 2>&1; then
    echo "gwpr: GitHub CLI (gh) is required." >&2
    return 1
  fi

  if [ $# -lt 1 ]; then
    echo "Usage: gwpr <pr-number> [slug]" >&2
    return 1
  fi

  local pr="$1"
  local user_slug="$2"
  local repo_dir

  _gw_ensure_repo || return 1
  repo_dir=$(_gw_repo_dir) || return 1
  mkdir -p "$repo_dir"

  local base
  if [ -n "$user_slug" ]; then
    base="$user_slug"
  else
    base=$(gh pr view "$pr" --json headRefName,title --jq '.headRefName // .title' 2>/dev/null)
    [ -z "$base" ] && base="pr-$pr"
  fi

  local clean slug
  clean=$(printf '%s\n' "$base" |
    tr '[:upper:]' '[:lower:]' |
    sed -E 's/[^a-z0-9]+/-/g; s/^-+//; s/-+$//')

  [ -z "$clean" ] && clean="pr"

  slug="${pr}-${clean}"
  local branch="pr/${slug}"
  local target_dir="${repo_dir}/${slug}"

  echo "Creating worktree for PR #$pr"
  echo "  branch: $branch"
  echo "  path:   $target_dir"
  echo

  git worktree add --detach "$target_dir" || return 1

  (
    cd "$target_dir" || exit 1
    gh pr checkout "$pr" --branch "$branch"
  )
}

# -----------------------------
# Aliases
# -----------------------------

alias gwt='gwls'
alias gwtnew='gwn'
alias gwtremove='gwrm'
alias gwtprune='gwprune'
